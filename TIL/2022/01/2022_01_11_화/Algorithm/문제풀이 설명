++++++++++++++++++++++

    function solution(arr1, arr2) {
        var answer = [];
        let demo = [];
        for(let i = 0; i < arr1.length; i++) {
            for(let j = 0; j < arr1[i].length; j++) {
                demo.push(arr1[i][j] + arr2[i][j]);
            }
        }
        let length = demo.length / arr1.length;
        while(demo.length !== 0) {
            answer.push(demo.slice(0, length));
            demo.splice(0, length);
        }
        return answer;
    }

++++++++++++++++++++++

    arr1이 [[1,2],[2,3]]
    arr2가 [[3,4],[5,6]] 라는 가정을 예시로 설명해보겠다.

    demo라는 빈배열을 먼저 선언해준다.
    for반복문으로 모든 값들을 더해주는데 단순히 0번째 인덱스부터 마지막 인덱스까지의 값을 더하는것이 아닌,
    arr1의 0번째 인덱스의 0번째 값은 arr2의 0번째 인덱스의 0번째 값과 더해주고,
    arr1의 1번째 인덱스의 1번째 값은 arr2의 1번째 인덱스의 1번째 값과 더해주는것이다.
    즉 arr1[0][0] + arr2[0][0]을 해주고 arr1[1][1] + arr2[1][1] 을 해주는 식으로
    같은 인덱스에 위치한 숫자들끼리만 더해주는 방식이다.
    그렇게 해주면 demo에는 [4, 6, 7, 9] 가 담긴다.
    왜냐? 
    1과 3을 더해서 4,
    2와 4를 더해서 6,
    2와 5를 더해서 7,
    3과 6을 더해서 9 가 되기 때문이다.

    문제는 위 반복문처럼 for문을 사용하면 2차원 배열이 아닌 그냥 일반 배열로 답이 담기게 되는것이다.
    즉 우리가 리턴해줘야 하는 값은  [[4,6],[7,9]] 가 되어야 하는데 [4, 6, 7, 9] 로 되었다는 말이다.
    
    이걸 어떻게 해결해줄까 생각하다가 찾은 방법이,
    우선 몇개씩 나눠서 배열에 담아 2차원 배열을 만들어 줘야 하냐 가 알아야 하는 첫 단계였기 때문에
    length 라는 변수에 demo.length 나누기 arr1.length 를 해줬다.
    그냥 arr1[0].length 로 해줘도 되긴 하지만 좀 더 정확하게 하고싶어서 위 방법대로 해줬다.
    여기서 설명하는 경우는 위에 적어놓은 것처럼 arr1[0]의 길이가 2일때를 예를 든거지만
    입출력 예시 두번째것만 봐도 arr1[0]의 길이가 항상 2는 아니라는걸 알 수 있기때문에
    arr1[0]의 길이가 1일때도 있고 3일때도 있고 4일때도 있기 때문에 그에 맞는 길이를 찾아주는 demo.length / arr1.length 를 사용한것이다.

    그렇게 해서 length의 값을 우선 찾았고,
    이제 while반복문을 활용해서 answer.push(demo.slice(0, length)) 를 해주는데 이렇게 하면
    demo가 [4, 6, 7, 9] 일때 4랑 6을 한 배열에 담아 answer에 push를 해주게 된다. 즉 answer는 [[4, 6]]이 되는것이다.
    근데 이렇게 끝나면 안되고 7과 9도 처리를 해줘야 했기 때문에 한번 0부터 length까지의 인덱스(4와6)를 answer에 담아줬으면
    demo의 값을 0부터 length까지의 값들을 지워주고 다시 반복문을 실행해야 한다.
    demo의 값을 지우지 않고 반복문을 돌리면 answer는 [[4, 6], [4, 6]]이 되기때문에 맞는 답이 아니다.
    while문의 조건을 demo의 길이가 0이 아닐때까지만 실행한다 라고 정해주고,
    demo의 값들을 length 만큼 나눠서 answer에 배열로 넣어주면 결국 우리가 원하는 값을 리턴해줄 수 있게 된다.

    ~~

    다 풀고보니 엄청 복잡하게 푼 기분이 든다.
    첨부한 더 나은 문제풀이1을 보면 단순히 처음 사용한 for반복문만 조금 다르게 활용했었다면 이렇게 복잡하게 풀지 않았어도 되었는데,
    for반복문을 잘 활용하지 못한 것 같다.
    
    그 외에도 다 나은 문제풀이2를 보면 map을 활용해서 단 1줄로 문제를 풀어냈는데,
    아직까지도 map과 filter 그리고 reduce의 활용법에 대해서 잘 모르고 있는 것 같다.
    아니 자주 활용을 하지 않다보니 익숙하지 않은 것 같다.
    
    알고리즘 문제들을 계속 자주 풀다보면 map과 filter 그리고 reduce의 활용법에 대해서도 익숙해질테니,
    오늘처럼 이렇게 쉽게 풀 수 있는 문제들을 더 이상 복잡하게 풀지 않아도 되게 되는 날이 오겠지.
    뭔가 아직 엄청나게 부족하구나 내가 그런 생각이 든다.

++++++++++++++++++++++
