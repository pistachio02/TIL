++++++++++++++++++++++

    오전에 지금까지 했던 Carrot Market 전체적으로 공부해보면서 정리해봤다.
    하지만 따로 발표를 하진 않을 것 같다고 하셔서 우선 정리한채로 보관해뒀다.

    그 이후부터 오후 3시 50분까지는 대표님께서 주신 프로젝트 관련 keynote 자료를 가지고 영문으로 번역이 필요한 부분들에 대해서 조금씩 번역을 해봤다.
    오래 걸리지 않을거라 생각했는데 생각보단 시간이 좀 더 걸렸던 것 같다.
    아무래도 기본적으로 한자와 한국어 단어가 주는 느낌들이 영어로 표현되는게 쉽지가 않았기도 했고,
    더구나 전문적인 단어들도 많이 섞여있다보니 생각했던것보다는 시간이 좀 더 걸린것 같다.

    오전에 대표님과 잠시 티타임을 가지면서 앞으로의 프로젝트에 대해서 살짝 얘기를 들어봤는데,
    아무래도 규태님과 내가 백엔드 부분을 맞아서 할거같고, 
    프론트쪽도 같이 하는 풀스택도 필요할거같은데 만약 둘 중 조금 더 센스가 있어 보이는 사람이 있다면 그 사람이 풀스택이 될 것 같다고 하신다.
    앞으로의 프로젝트는 아무래도 몽고DB를 사용하게 될 것 같다고 하셨어서 몽고DB도 조금 더 공부를 해봐야 할 것 같고,

    기본적으로 우리가 앞으로 해야할 일들은 우선 프로젝트의 페이지들을 보면서 필요할것같은 api들을 쭉 한 번 생각해서 list-up을 해보고,
    그 이후 정리된 api list들을 가지고 누가 어떤 파트를 맞아서 할지 정해서 본격적으로 시작하게 될 예정일 것 같다.
    
    아무튼 퇴근때까지 화이팅이다.

++++++++++++++++++++++

    공부해야 할 것?

    - 몽고DB (몽구스)
    - 아틀라스?
    - 레이어링 개념
    - 코멘트 룰 개념

++++++++++++++++++++++

    NoSQL은 SQL이 없다는 의미가 아니라 Not Only SQL의 약자이다.
    기존의 RDBMS의 한계를 극복하기 위해 만들어진 새로운 형태의 저장소이다.
    고정된 스키마를 가지고 있지 않으며, Join이 불가능하다.

++++++++++++++++++++++

    몽고디비에선 아래와 같이 데이터를 DB에 담는다.

    {
        "_id": ObjectId("5099803df3f4948bd2f98391"),
        "username": "velopert",
        "name": { first: "M.J.", last: "Kim" }
    }

++++++++++++++++++++++

    문서는 동적인 스키마를 가질 수 있는데 여러 문서들이 들어있는 곳을 컬렉션이라고 부른다.
    기존의 RDBMS 에서는 테이블이란 개념을 사용하고, 각 테이블마다 같은 스키마를 가졌어야만 했는데, 따라서 만약 데이터의 구조를 바꿔야 한다면 전체 데이터를 바꿔줘야만 했다.
    하지만 몽고DB에서는 한 컬렉션에서 다른 스키마를 가지고 있을 수 있다.
    아래 예시와 같다.

    { 
        "_id": ObjectId("594948a081ad6e0ea526f3f5"),
        "username": "velopert"
    },
    { 
        "_id": ObjectId("59494fca81ad6e0ea526f3f6"),
        "username": "nakim",
        "phone": "010-3333-6666"
    }

    위를 보면 알 수 있듯이 한 데이터에는 phone이 없고 다른 데이터에는 phone이 있다.
    기존 RDBMS 에서는 동일한 스키마를 가졌어야 하기때문에 위처럼 어느곳에는 특정 데이터가 있고 어느곳에는 없고 그렇게 할 수가 없었다.
    하지만 몽고DB에서는 위와같은 다른 스키마를 가질 수 있기 때문에 위와같이 데이터를 보관할 수가 있다.

++++++++++++++++++++++

    몽고DB에서는 Join이 불가능하기 때문에 한 데이터 안에 최대한 우리가 필요로 하는 많은 정보를 담는게 좋다.
    예를 들어 만약 기존의 RDBMS 방법대로라면 post 테이블과 comment 테이블을 따로 만들어 두개를 join해 필요한 데이터들을 불러올 수 있었다면,
    몽고DB에서는 한 post 데이터 안에 배열로 따로 comment 데이터를 포함해 넣어줘야 한다.
    그렇게 해야 한번 post에 대한 정보를 불러올 때 해당 post에 대한 comment까지 한번의 쿼리로 다 불러올 수 있게 되기 때문이다.
    보통 한 문서에는 대략 16mb 정도의 데이터를 넣을 수 있는데 이는 글자로 했을때 68000정도의 글자수가 된다.
    만약 이 리밋을 넘지 않는다면 한 데이터 안에 최대한 많은 정보를 넣어 보관하는게 좋은 방법이지만,
    만약 이 리밋을 넘게 된다면 따로 컬렉션을 분리해서 관리하는것이 좋다.
    예를 들어 post의 컬렉션과 comment의 컬렉션을 만들게 된다면 post 문서 안에 comment 문서의 id를 넣어줘서,
    두번 쿼리를 실행해 관련된 데이터를 불러오는것이다.
    물론 컬렉션이 2개라면 이에 따라 쿼리도 두번씩 해줘야 하는 번거로움이 있지만 데이터베이스 인덱싱만 잘 되어있다면,
    성능상으로는 RDBMS 에서의 JOIN 과 큰 차이가 나지 않는다.

++++++++++++++++++++++

    MongoDB 설치방법

    - brew tap mongodb/brew
    - brew install mongodb-community
    - mongo -version
    - brew services start mongodb-community
        ㄴ 몽고디비 실행시키기
    - brew services stop mongodb-community
        ㄴ 몽고디비 비활성화하기
    
    Mongo Shell 실행법
    - mongo

++++++++++++++++++++++
