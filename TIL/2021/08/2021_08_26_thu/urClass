SQL?

-> Structured Query Language (구조화된 Query 언어)
-> 데이터베이스용 프로그래밍 언어로, 데이터베이스에 query를 보내 원하는 데이터만을 뽑아올 수 있다.

Query란?
-> 저장되어있는 정보를 필터하기 위한 질문이라고 볼 수 있다.

Database가 필요한 이유?

-> In-memory로 서버에 데이터를 저장했을때 서버를 끄면 데이터가 없어짐.
-> File I/O로 서버에 저장하게되면 원하는 데이터만 가져올 수 없고, 항상 모든 데이터를 다 가져온 뒤 서버에서 필터링을 해야함, 이말은 곧 서버에 부하가 갈 수 있음.
-> Database는 데이터에 특화된 서버로써 필터링 외에도 File I/O로 구현이 힘든 관리를 위한 여러 기능들을 가지고 있기에 사용하기 용이.


보통 많이 사용하는 기본 쿼리문들?
⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇

-> Select // 뽑아오고싶은 데이터를 선택하기 위한 select문 , 예). select * from user (user 테이블에서 모든 데이터들을 다 조회한다.)
-> Where // 조건문을 작성할때 사용, 예). select * from user where user.name = 'jung' (유저 이름이 jung인 모든 데이터들을 user 테이블에서 조회한다.)
-> And, Or, Not // 말그대로 and, or, not 연산, 예). where not user.name = 'jung' (유저 이름이 jung이 아닌것을 뜻함.)
-> Order By // 말그대로 데이터들을 정렬시키는것, 기본값은 오름차순, desc로 하면 내림차순으로 정렬 가능, 예). order by name desc (이름을 기준으로 내림차순으로 정렬)
-> Insert Into // 새로운 데이터를 입력하고싶을때 사용, 예). insert into 테이블명(컬럼명1, 컬럼명2, 컬럼명3, ...) values (컬럼명1의 값, 컬럼명2의 값, 컬럼명3의 값, ...)
-> Null Values
-> Update // 데이터를 수정할때 사용, 예). update 테이블명 set 컬럼명1 = 컬럼명1의 값, 컬럼명2 = 컬럼명2의 값, ... where 조건
-> Delete // 말그대로 삭제, 예). delete from 테이블명 where 조건
-> Count // 수를 세어야할때 사용, 예). select count(컬럼명) from 테이블명 where 조건
-> Like // where 이후에 조금 더 세부적인 조건을 달아야 할떄 사용, 예). select * from customers where CustomerName like 'a%' (customers 테이블에서 CustomerName이 알파벳 a로 시작하는 모든 정보들을 조회), '%a'는 알파벳 a로 끝나는걸 의미, '&aa&'는 알파벳 aa가 어느 위치던 위치해있을때를 의미.
-> Wildcards
-> Aliases
-> Joins // 2개 이상의 테이블들의 정보를 조인시킬 수 있다.
-> Inner Join // 2개의 테이블이 있을때 양쪽 테이블 모두에게 맞는 데이터가 있을때를 의미
-> Left Join // 2개의 테이블이 있을때 왼쪽(첫째테이블)의 모든 정보와, 오른쪽(둘째테이블)의 맞는 데이터가 있을때를 의미.
-> Right Join // 위와 반대로 2개의 테이블이 있을때 오른쪽(둘째테이블)의 모든 정보와 왼쪽(첫째테이블)의 맞는 데이터가 있을때를 의미.
-> Group By // 보통 count(), max(), min(), sum(), avg() 와 함께 자주 사용하고, 조회한 데이터들을 그룹화 시킬때 사용한다. 예). select 컬럼명 from 테이블명 where 조건 group by 컬럼명 order by 컬럼명


보통 많이 사용하는 데이터베이스 관련 용어들?
⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇⬇️⬇️⬇️⬇️⬇️

-> SQL Create DB // db를 만들때 사용
-> SQL Drop DB // db를 삭제할때 사용
-> SQL Create Table // table을 만들때 사용
-> SQL Drop Table // table을 삭제할때 사용
-> SQL Alter Table // table의 컬럼을 추가, 삭제, 수정 할때 사용, 예). alter table 테이블명 add 컬럼명 데이터 타입 (alter table user add email varchar(255);)
-> SQL Not Null // 컬럼의 값으로 null을 받지 않겠다는 의미
-> SQL Unique // 데이터의 값이 유니크하다를 의미(값들이 많아도 동일한게 하나도 없다는 의미)
-> SQL Primary Key // 고유한 키를 의미
-> SQL Foreign Key // 다른 테이블에서 값을 참조할때 사용
-> SQL Default // 초기값을 설정해주고 싶을때 사용
-> SQL Auto Increment // 새로운 데이터가 테이블에 추가 되었을때 새로운 번호를 매겨준다 예). id라는 컬럼이 있을때 새로운 데이터가 들어오면 자동으로 숫자를 올려줌 (1, 2, 3, ...)
-> SQL Dates // 말 그대로 날짜를 의미



ACID?

-> Atomicity , Consistency, Isolation, Durability 를 의미

Atomicity>

-> 원자성을 의미, 하나의 트랜잭션이 있을때 모든 작업이 전부 성공하거나 전부 실패해서 결과를 예측 할 수 있어야 한다. 예를 들어 내가 누군가에게 송금을 하려 할때 2가지로 작업을 크게 나눠볼 수 있다. 내 계좌에서 출금, 그리고 상대 계좌로 입금. 그런데 만약 내 계좌에서 출금 작업을 완료 하고 트랜잭션이 멈추거나 오류가 났을때 성공했던 내 계좌에서의 출금까지도 모두 실패해야하는것을 의미한다. 즉 출금 및 송금이 모두 성공하거나 모두 실패해야지, 출금만 되거나 송금만 되거나 하는 문제가 발생하지 않기때문에 이 원자성이 필요한것이다.

Consistency?

-> 일관성을 의미, 하나의 트랜잭션 이전과 이후, 데이터베이스의 상태는 이전과 같이 유효해야함을 의미, 다시말해 트랜잭션이 일어난 이후의 데이터베이스는 데이터베이스의 제약이나 규칙을 만족해야 한다는 뜻, 예를 들면 모든 고객은 반드시 이름을 가지고 있어야 한다는 데이터베이스 제약이 있다고 했을때, 이름없는 새로운 고객을 추가하는 쿼리나 기존 고객의 이름을 삭제하는 쿼리는 있을 수 없다, 왜냐? 모든 고객은 반드시 이름을 가지고 있어야 한다는 데이터베이스 제약이 있기때문에 어떠한 트랜잭션 이후에는 반드시 테이터의 상태에 대한 일관성은 변하지 않아야 한다.

Isolation?

-> 격리성, 고립성을 의미, 모든 트랜잭션은 다른 트랜잭션으로부터 독립되어야 한다는 의미이다. 예를 들면 내 계좌에 1만원이 있고 친구1에게 6000원, 친구2에게 6000원 씩 동시에 송금을 하려 했을때 두개의 송금이 모두 성공해서 내 계좌에 -2000원이 찍히는것이 아닌 먼저 친구1에게 6000원을 송금하고 나머지 트랜잭션을 실행해야 한다는 의미다. 즉 다시말해 동시에 2개의 트랜잭션을 시킨다고 해도 2개의 트랜잭션을 순서대로 진행한것과 같은 결과가 나와야 한다는 의미이다.

Durability?

-> 지속성을 의미, 하나의 트랜잭션이 성공적으로 수행되었다면 해당 트랜잭션에 대한 로그가 남아야 한다. 만약 런타임 오류나 시스템 오류가 발생하더라도 해당 기록은 영구적이어야 한다는 의미이다. 예를 들면 내가 친구1에게 1만원을 송금하는 트랜잭션을 실행하고 성공했을시 그 트랜잭션 이후 바로 오류로 인해 시스템이 종료된다 하더라도 내가 진행한 1만원 트랜잭션에 대한 기록은 계좌이체 내역으로 남아야 한다는 의미이다.



SQL vs NoSQL?

-> 데이터베이스는 크게 관계형 데이터베이스와 비관계형 데이터베이스로 구분합니다. 관계형 데이터베이스는 SQL을 기반으로 하고, 비관계형 데이터베이스는 NoSQL로 데이터를 다룬다. 

-> 관계형 데이터베이스는 행(row)과 열(column)로 구성된 테이블에 데이터를 저장한다.
-> 관계형 데이터베이스에서는 테이블 간의 관계를 직관적으로 파악할 수 있다.

-> NoSQL은 주로 데이터가 고정되어 있지 않은 데이터베이스를 가리킨다.
-> NoSQL 기반의 비관계형 데이터베이스는 보통 Key-Value 타입 : 속성을 Key-Value의 쌍으로 나타내는 데이터를 배열의 형태로 저장한다.
-> NoSQL 기반의 비관계형 데이터베이스는 보통 문서형(Document) 데이터베이스 : 데이터를 테이블이 아닌 문서처럼 저장한다.

-> 일반적으로 SQL 기반의 관계형 데이터베이스는 수직적으로 확장한다. 높은 메모리, CPU를 사용하는 확장이라고도 한다. 데이터베이스가 구축된 하드웨어의 성능을 많이 이용하기 때문에 비용이 많이 든다. 여러 서버에 걸쳐서 데이터베이스의 관계를 정의할 수 있지만, 매우 복잡하고 시간이 많이 소모되는 편이다.

-> NoSQL로 구성된 데이터베이스는 수평적으로 확장한다. 보다 값싼 서버 증설, 또는 클라우드 서비스를 이용하는 확장이라고도 한다. NoSQL 데이터베이스를 위한 서버를 추가적으로 구축하면, 많은 트래픽을 보다 편리하게 처리할 수 있고, 저렴한 범용 하드웨어나 클라우드 기반의 인스턴스에 NoSQL 데이터베이스를 호스팅할 수 있어서, 수직적 확장보다 상대적으로 비용이 저렴하다고 볼 수 있다.


Tip!!
⬇️⬇️⬇️⬇️

-> 데이터베이스의 ACID 성질을 준수해야 하는 경우 / 소프트웨어에 사용되는 데이터가 구조적이고 일관적인 경우 , SQL기반의 관계형 데이터베이스를 사용하면 좋다.

-> 데이터의 구조가 거의 또는 전혀 없는 대용량의 데이터를 저장하는 경우 / 클라우드 컴퓨팅 및 저장공간을 최대한 활용하는 경우 / 빠르게 서비스를 구축하는 과정에서 데이터 구조를 자주 업데이트 하는 경우 , NoSQL 기반의 비관계형 데이터베이스를 사용하면 좋다.