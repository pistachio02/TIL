<TIL>

Toy 번

문제
-> 정수를 요소로 갖는 배열을 입력받아 이진 힙(binary heap)*을 리턴해야 합니다.
-> 이진 힙(binary heap)은 노드의 값이 특정한 순서를 가지고 있는 완전 이진 트리(Complete Binary Tree)입니다.
-> 완전 이진 트리는 이진 트리의 (마지막 레벨 또는 마지막 깊이를 제외하고) 모든 레벨이 노드로 가득 채워져 있어야 합니다. 마지막 레벨은 왼쪽부터 차례대로 채워져 있습니다.
-> 이진 힙에서 부모 노드의 값이 (이진 트리이므로 2개의) 자식 노드의 값보다 큰 경우를 최대 힙(max heap), 반대의 경우를 최소 힙(min heap)이라고 합니다.


인자  1 : arr
-> number 타입을 요소로 갖는 배열
-> arr[i]는 -100,000 이상 100,000 이하의 정수
-> arr.length는 100,000 이하


출력
-> number 타입을 요소로 갖는 배열을 리턴해야 합니다.


주의사항
-> 최대 힙(max heap)을 구현해야 합니다. // 부모노드가 항상 자식노드보다 큰 값을 가지는것이 최대 힙.
-> 입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.
-> 최대 힙 구현을 위해 선언된 함수들(getParentIdx, insert)을 전부 완성해야 합니다.
-> swap, getParentIdx, insert를 전부 사용해야 합니다.
-> swap, binaryHeap을 수정하지 않아야 합니다.
-> 테스트 케이스에서 힙 함수들을 정확히 구현했는지 함께 테스트합니다.
-> insert의 시간 복잡도는 O(logN)입니다.
-> 주어진 배열을 내림차순으로 정렬(O(logN))해도 최대 힙의 조건을 만족합니다. 하지만 이는 insert를 구현하는 것과는 거리가 먼 방법이며, 테스트를 통과할 수도 없습니다.


입출력 예시
⬇️⬇️⬇️⬇️⬇️⬇️

let output = binaryHeap([5, 4, 3, 2, 1]);
console.log(output); // --> [5, 4, 3, 2, 1]

output = binaryHeap([3, 1, 21]);
console.log(output); // --> [21, 1, 3]

output = binaryHeap([4, 10, 3, 5, 1]);
console.log(output); // --> [10, 5, 3, 4, 1]

// 위 문제를 이해하려면 우선 트리구조가 어떻게 배열로 표현 되는지 이해해야함.
// 만약 아래와 같은 트리구조가 있다면,
        10
       /  \
      3    8
     / \  / \
     1 6  7 9
// 위 트리구조를 배열로 표현하면 [10, 3, 8, 1, 6, 7, 9] 가 된다.
// 이게 이해가 됬다면 이제 문제를 이해해야 하는데, 어떠한 배열이 들어왔을때 그것을 어떻게 이진힙으로 리턴하느냐가 문제인데
// 우리가 이해해야 하는것은 일단 트리를 만들때 들어온 배열의 순서대로(0번째 인덱스부터 마지막 인덱스까지) 트리에다가 넣어줄거고,
// 만약 배열 [7, 3, 2, 9, 4, 1, 0] 이 들어왔다면 이걸 트리로 하면 아래와 같이 된다.
                 7
                / \
               3   2
              / \ / \
              9 4 1 0
// 자 이거까지 이해가 됬다면 이제 조건인 최대힙(부모노드는 항상 자식노드보다 큰 값이어야 한다)을 만족하면서 트리를 만들어야 하는데
// 위에 들어온 배열 [7, 3, 2, 9, 4, 1, 0] 를 그냥 단순히 순서대로 넣어서 트리를 만들면 위 트리가 되겠지만,
// 이거를 최대힙으로 구현하면 아래와 같이 된다.
                                         9
                                        / \
                                       7   2
                                      / \ / \
                                      3 4 1 0
// 왜 위 트리처럼 되냐 생각해보면 우리가 입력된 배열의 값을 트리에 순서대로 쭉 넣다보면 7, 3, 2까지는 조건에 만족하면서 넣게 된다, 왜? 7을 제일 처음에 부모노드에 넣고, 3 과 2를 넣으려 했을때 3 과 2 모두 7보다 작기때문에.
// 그런데 문제는 9가 들어왔을때이다, 9가 들어오면 부모노드인 3보다 값이 크기때문에 9를 부모노드로 두고 3을 자식노드로 바꿔줘야 한다, 즉 그냐야 9랑 3이랑 서로 위치를 바꿔준다. 
// 근데 또 문제는 9랑 3이랑 바꿔줬는데 그 상태에서 9의 부모노드를 보니 7이야, 그럼 또 9는 7보다 크기때문에 9랑 7이랑 서로 위치를 바꿔줘야한다.
// 그리고는 9가 더이상 부모 노드가 없거나 부모노드가 있다해도 9보다 큰걸 알았으면 이제 그 다음 숫자로 넘어간다.
// 4는 그대로 7보다 작기때문에 넣어주고, 1도 0도 2보다 작기때문에 그대로 넣어준다.
// 여기서 중요한것, 잊지 말아야 하는것은, 최대힙은 이진 검색 트리랑 다르게 오직 부모와 직계자식들 간의 관계만 유지된다.
// 이게 뭔말이냐 하면 이진 검색 트리는 모든 노드가 정렬되는데, 최대힙에선 부모와 자식간의 관계만 본다 이뜻이다.
// 위 트리를 예시로 들자면 7을 기준으로 봤을때 자식노드가 3과 4가 있는데 3은 4보다 큰데 어째서 먼저 할당 되었지? 라고 생각할 수 있지만 3과4는 형제 관계로 최대힙에선 신경쓰지 않는다. 위 최대힙 트리를 배열로 봤을때는 [9, 7, 2, 3, 4, 1, 0]이 되는데 3보다 4가 큰데 왜 뒤에있어? 라고 잠깐 생각할 수 있지만 다시 말하자면 3과 4는 형제관계이기에 어디가 크고 어디가 작은지 신경쓰지 않는다.
// 우리가 주목해야하는것은 배열을 입력 받았을때 어떤 순서대로 트리에 넣는지, 또 부모와 자식간의 관계만 생각했을때 최대힙이라는 조건을 어떻게 만족시켜주는지(부모와 입력하려는 자식의 값을 그냥 단순히 위치만 서로 바꿔줌) 그것만 신경쓰면 된다.

// 그래서 위 입출력 예시 두번째것만 봐도, 배열 [3, 1, 21] 이 주어졌을때 왜 결과가 [21, 1, 3]가 나오는지 이해가 안될수 있는데, 트리로 만들다 보면 이해가 된다. 아래 트리를 보면서 참고.

        3                                                  21       최대힙 조건을 만족한 트리를 다시 
       / \    단순히 순서대로 트리를 만들면 왼쪽처럼 된다.           / \       배열로 만들어 주면 [21, 1, 3]
      1  21   근데 21이 3보다 크네? 그러면 서로 위치를 바꾸자.      1  3      이러면 이제 왜 결과가 이렇게 나오는지 이해가 된다.

// 다시 말하지만 형제 관계는 신경쓰지 않기 때문에 3이 1보다 커도 배열은 [21, 3, 1]이 아닌 [21, 1, 3]이 되는것이다.



힌트!!!!!!!!!
⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️

-> 이진 힙은 트리 객체를 이용해 구현할 수도 있고, 배열로도 구현할 수 있습니다. 사실 거의 모든 트리를 배열로 구현할 수 있습니다. 트리를 배열로 구현했을 때의 장점은 (데이터가 선형적으로 저장되기 때문에) 저장공간을 절약할 수 있고 노드 접근 시 오버헤드(재귀호출, 반복문 등)가 약간 줄어듭니다. 다만 이를 위해서 매우 복잡한 인덱스 관리가 필요합니다. 반면, 트리 객체를 이용한 구현은 직관적(이해하기 쉬움)입니다. 그 대신 저장 공간과 약간의 오버헤드를 희생해야 합니다. 거의 모든 기술(구현)은 다수의 선택 사이의 트레이드 오프(trade-off)입니다. 무엇을 선택할 지는 요구사항(requirements), 즉 주어진 문제의 제약과 조건을 고려하여 결정해야 합니다. 이 점을 반드시 기억하시기 바랍니다.
-> 완전 이진 트리는 노드가 낮은 레벨부터 채워지고, 같은 레벨에서는 왼쪽부터 채워지기 때문에 배열로 구현하는 것이 쉽습니다.
-> 최대 힙과 이진 검색 트리(binary search tree)는 둘다 완전 이진 트리입니다. 하지만 이진 검색 트리에서는 모든 노드가 정렬되는 것과 달리 최대 힙에서는 오직 부모 노드와 직계 자식들 간의 관계만 유지됩니다. 이는 아래의 사실로부터 바로 알 수 있습니다.
    - 이진 검색 트리에서 오른쪽 자식 노드의 값은 부모 노드의 값보다 크지만, 최대 힙에서는 부모 노드의 값이 두 자식 노드의 값보다 크다.
-> 아래와 같은 최대 힙에서 10을 삽입할 경우, 최대 힙을 유지하려면 어떻게 해야하는 지 고민하시기 바랍니다.

                     9
                    / \
                   6   7
                  / \ / \
                  4 5 2
-> 최소 힙은 부모 노드의 값이 두 자식 노드의 값보다 작다는 점을 제외하고는 최대 힙과 구현이 일치합니다. 아래 링크는 최소 힙의 동작을 눈으로 직접 확인할 수 있습니다. 참고하시기 바랍니다.
    - https://www.cs.usfca.edu/~galles/visualization/Heap.html


문제 풀이
⬇️⬇️⬇️⬇️⬇️

// 아래 코드는 수정하지 마세요.
function swap(idx1, idx2, arr) {
  // 두 변수를 바꾸는 방법

  // 1) 임시 변수를 활용한 방법
  // let temp = arr[idx1];
  // arr[idx1] = arr[idx2];
  // arr[idx2] = temp;

  // 2) Destructuring assignment를 활용한 방법
  // arr이 reference type이라 가능
  [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];  // 배열의 인덱스1과 인덱스2의 위치를 바꿔주는 방법.

  // 3) XOR 연산을 활용한 방법
  // arr이 reference type이라 가능
  // arr[idx1] ^= arr[idx2];
  // arr[idx2] ^= arr[idx1];
  // arr[idx1] ^= arr[idx2];
}

function getParentIdx(idx) {
  // TODO: 여기에 코드를 작성합니다.
  return Math.floor((idx - 1) / 2); 
}

function insert(heap, item) {
  // TODO: 여기에 코드를 작성합니다.
  heap.push(item);
  let curIdx = heap.length - 1;
  let pIdx = getParentIdx(curIdx);
  while (pIdx >= 0 && heap[curIdx] > heap[pIdx]) {
    swap(curIdx, pIdx, heap);
    curIdx = pIdx;
    pIdx = getParentIdx(curIdx);
  }
  return heap;
}

// 아래 코드는 수정하지 마세요.
const binaryHeap = function (arr) {
  return arr.reduce((heap, item) => {
    return insert(heap, item);
  }, []);
};
