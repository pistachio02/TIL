<네트워크 심화>

네트워크?
-> 네트워크는 OSI 7계층 또는, TCP/IP 4계층으로 구분한다.


-------------------------------------------------------------


인터넷 프로토콜?

ip와 ip packet?
-> 복잡한 인터넷 망 속에서 어떻게 클라이언트랑 서버가 잘 통신할 수 있을까 알아보자.
-> 출발지에서 목적지까지 데이터가 무사히 잘 전달되기 위해선 어떠한 규칙이 필요할거같다.

-> 우리는 ip(internet protocol) 주소를 컴퓨터에 부여해서 이를 이용해 통신한다.
-> ip는 지정한 ip주소에 packet이라는 통신의 단위로 데이터를 전달하게 된다.
-> ip packet 에서 packet 은 pack과 bucket이 합쳐진 단어로 소포로 비유할 수 있다.
-> ip packet은 이를 데이터 통신에 적용한거라고 보면 된다.
-> ip packet은 우체국 송장처럼 전송 데이터를 무사히 전송하기 위해 출발지 ip, 목적지 ip와 같은 정보가 포함되어 있다.
-> 위에 설명한대로 이처럼 packet 단위로 데이터를 전송하게 되면 노드들은 목적지 ip에 도착하기 위해 서로서로 데이터를 전달하게 된다. 그래서 복잡한 인터넷 망에서도 정확하게 목적지로 packet 즉 데이터를 전송 할 수 있는것이다.
(여기서 노드는 하나의 서버 컴퓨터를 의미한다.)
-> 이렇게 클라이언트에서 서버로 packet 단위로 데이터를 전송했을 시 무사히 서버로 packet이 잘 도착하게 된다면, 서버도 이에 대한 응답으로 ip packet을 이용해 클라이언트에게 응답을 전송하게 된다.

-> 정확한 출발지와 목적지를 파악할 수 있다는 점에서 ip 프로토콜은 적절한 통신 방법으로 보이지만, 이러한 ip 프로토콜에도 이와같은 한계가 존재한다.

-> 첫번째 문제는? 비연결성.
    - 만약에 packet이 전송되었는데 받을 대상(서버)이 없거나, 서비스 불능 상태이더라도 클라이언트에서는 그러한 서버의 상태를 파악할 방법이 없기 때문에 일단 packet을 그대로 전송하게 된다.
-> 두번째 문제는? 비신뢰성.
    - 중간에 있는 서버(노드)가 데이터를 전달하던 중 장애가 생겨 패킷이 중간에 소실되더라도 클라이언트는 이를 파악할 방법이 없다.
    - 또한 만약 전송해야 하는 데이터의 용량이 엄청나게 클 경우 한꺼번에 전송할 수 없기때문에 여러 packet으로 나눠 전송해야 하는데, 이럴때 다수의 packet이 중간에 이동하면서 서로 다른 노드(하나의 서버 컴퓨터)를 통해 전달될 수 있어서 최종적으로 서버에서 packet들을 다 받았을때 클라이언트가 의도한 순서대로 받지 못하고 순서가 뒤죽박죽 섞인채로 받을 수 있다.


그렇다면 위 ip packet의 한계들을 보완하기 위해 뭐라도 해야하겠지?
네트워크 계층 구조를 통해 이와 같은 한계를 어떻게 보완할 수 있을 지 알아보자.


-> 네트워크 프로토콜 계층은 OSI 7계층과 TCP/IP 4 계층으로 나눌 수 있는데,
-> 그 중 OSI 7계층을 살펴보면 위에서 설명한 IP 프로토콜 보다 더 높은 계층에 TCP 프로토콜이 존재하기 때문에 위에서 설명한 문제점들을 TCP 프로토콜로 어느정도 보완할 수 있다.
(TCP/IP 4 계층은 OSI 7 계층보다 먼저 개발되었고, TCP/IP 프로토콜의 계층은 OSI 모델의 계층과 정확하게 일치하지는 않는다.)

-> 채팅 프로그램에서 메세지를 보낼때를 예시로, 메세지를 보낼 때 어떤 일이 일어나는지 한번 알아보자.

-> 먼저 HTTP 메시지가 생성되면 Socket 라이브러리를 통해 메세지가 전달된다.
-> 프로그램이 네트워크에서 데이터를 송수신할 수 있도록, “네트워크 환경에 연결할 수 있게 만들어진 연결부“가 바로 네트워크 소켓(Socket)이다.
-> 그리고 IP 패킷을 생성하기 전 TCP 세그먼트를 생성한다.
-> 이렇게 생성된 TCP/IP 패킷은 LAN 카드와 같은 물리적 계층을 지나기 위해 이더넷 프레임 워크에 포함되어 서버로 전송된다.


-------------------------------------------------------------


TCP/IP 패킷?

-> TCP 세그먼트에는 IP 패킷의 출발지IP와 목적지IP의 정보를 보완할 수 있는 출발지 PORT, 목적지 PORT, 전송 제어, 순서, 검증 정보 등을 포함한다.

TCP 의 특징?

-> 연결지향 - TCP 3 way handshake(가상연결)
-> 데이터 전달 보증
-> 순서 보장
-> 신뢰할 수 있는 프로토콜로 (TCP는 같은 계층에 속한 UDP에 비해 상대적으로 신뢰할 수 있는 프로토콜이다.)

-> TCP는 장치들 사이에 논리적인 접속을 성립하기 위하여 3 way handshake를 사용하는 연결지향형 프로토콜이다.
-> 연결 방식은 다음과 같다.
    - 먼저 클라이언트는 서버에 접속을 요청하는 SYN 패킷을 보낸다.
    - 서버는 SYN요청을 받고 클라이언트에게 요청을 수락한다는 ACK 와 SYN가 설정된 패킷을 발송하고 클라이언트가 다시 ACK으로 응답하기를 기다린다.
    - 클라이언트가 서버로부터 받은 ACK를 다시 서버에게 보내면 이 이후로부터 연결이 성립되며 데이터를 전송할 수 있게된다.
    - 만약 서버가 꺼져있다면 클라이언트가 SYN을 보내고 서버에서 응답이 오지 않을거기 때문에 데이터를 보내지 않게된다.
    (현재에는 최적화가 이루어져 3번 ACK을 보낼때 데이터를 함께 보내기도한다. / SYN은 Syncronize, ACK는 Acknowledgment의 약자이다.)

-> TCP는 데이터 전송이 성공적으로 이루어진다면 이에 대한 응답을 돌려주기 때문에 IP 패킷의 한계인 비연결성을 보완할 수 있게된다.

-> 만약 패킷이 순서대로 도착하지 않는다면 TCP 세그먼트에 있는 정보를 토대로 다시 패킷 전송을 요청할 수 있다.
-> 그렇기 때문에 이를 통해 IP 패킷의 한계인 비신뢰성(순서를 보장하지 않음)을 보완할 수 있다.


UDP 의 특징?

-> 기능이 거의 없음(하얀 도화지에 비유)
-> 비연결지향 - TCP 3 way handshake 없음.
-> 데이터 전달 보증 안됨.
-> 순서보장 안됨.
-> 데이터 전달 및 순서 보장 안되지만 대신 엄청 단순하고 빠르다는 장점이 있음.
-> 신뢰성보다는 연속성이 중요한 서비스(예를 들자면 실시간 스트리밍 서비스)에서 자주 사용됨.

UDP?

-> UDP는 IP 프로토콜에 PORT, 체크섬 필드 정보만 추가된 단순한 프로토콜이다.
    - 체크섬(checksum)은 중복 검사의 한 형태로, 오류 정정을 통해, 공간(전자통신)이나 시간(기억장치) 속에서 송신된 자료의 무결성을 보호하는 단순한 방법이다.
-> 앞서 TCP 특징과 비교해보면 신뢰성은 낮지만 3 way handshake 방식을 사용하지 않기 때문에 TCP와 비교해 빠른 속도를 보장할 수 있다.
-> HTTP3는 UDP를 사용하고 이미 여러 기능이 구현된 TCP보다는 하얀 도화지처럼 커스터마이징이 가능하다는 장점이 있다.
-> 간단히 설명하자면, 좋은 기능이 다 들어있는 무거운 라이브러리는 TCP, 필요한 기능만 들어있는 가벼운 라이브러리는 UDP 로 이해하면 된다.




!!!!! 존나 길게 써놔서 읽기도 개빡치고 이해도 잘 안된다면 그냥 간단히 설명할테니 이것만 읽으면 됨. !!!!!

-> TCP는 연결지향형 프로토콜 / UDP는 비연결지향형 프로토콜
-> TCP는 전송 순서 보장 가능 / UDP는 전송 순서 보장 불가
-> TCP는 데이터 수신 여부 확인 가능 / UDP는 데이터 수신 여부 확인 불가
-> TCP는 위와같은 이유로 신뢰성 높지만 속도 느림 / UDP는 위와같은 이유로 신뢰성 낮지만 속도 빠름

!!!!! !!!!!


-------------------------------------------------------------


http?

-> HTTP/1.1, HTTP/2는 TCP 기반, HTTP/3는 UDP 기반 프로토콜이다.

http 특징?

-> 클라이언트, 서버 구조
    - 클라가 서버에 요청을 보내면 서버는 그에 대한 응답을 보내는 클라-서버 구조로 되어있다.
-> 무상태 프로토콜(stateless), 비연결성(connectionless)
    - 서버가 클라이언트의 상태를 보존하지 않는 무상태 프로토콜이다.
    - 무상태성의 장점은 언제든 응답 서버를 쉽게 바꿀 수 있는것이고, 
    - 언제든 응답 서버를 바꿀 수 있다는것은, 갑자기 클라의 요청이 증가하더라도 곧바로 서버를 대거 투입할 수 있다는것이다.
    - 즉 서버의 무한한 증설이 가능.
    - 하지만 이러한 장점 대비 단점도 존재하는데, 로그인이 필요없는 단순한 서비스 소개 화면같은 경우엔 무상태로 설계할 수 있지만 로그인이 필요한 서비스라면 유저의 상태를 유지해야 되기 때문에 브라우저 쿠키, 서버 세션, 토큰등을 이용해 상태를 유지해야 한다.
    - TCP/IP의 경우 기본적으로 연결을 유지하는데, 연결을 유지하는 모델에서는 클라이언트가 요청을 보내지 않더라도 계속 연결을 유지해야 한다. 이러한 경우 연결을 유지하는 서버의 자원이 계속 소모가 된다.
    - 비 연결성을 가지는 HTTP에서는 실제로 요청을 주고 받을 때만 연결을 유지하고 응답을 주고나면 TCP/IP 연결을 끊기때문에 최소한의 자원으로 서버 유지를 가능하게 한다.
    - HTTP 1.0 기준으로, HTTP는 연결을 유지하지 않는 모델이다. 트래픽이 많지 않고, 빠른 응답을 제공할 수 있는 경우,  비연결성의 특징은 효율적으로 작동한다. 하지만 트래픽이 많고, 큰 규모의 서비스를 운영할 때에는 비연결성은 한계를 보인다.
        - 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등 수 많은 자원이 함께 다운로드된다. 해당 자원들을 각각 보낼때마다 연결을 끊고 다시 연결하고 를 반복하는 것은 비효율적이기 때문에 지금은 HTTP 지속 연결(Persistent Connections)로 이 문제를 해결한다.
            - HTTP 지속 연결에서는 연결이 이루어지고 난 뒤 각각의 자원들을 요청하고 모든 자원에 대한 응답이 돌아온 후에 연결을 종료한다. 
-> http 메세지
-> 단순하고 확장이 가능함


-------------------------------------------------------------


http header 와 body?

-> HTTP 메시지는 헤더와 바디로 구분할 수 있다.
-> HTTP 바디에서는 데이터 메시지 본문(Message body)을 통해서 표현(Representation) 데이터를 전달한다.
-> 여기서 데이터를 실어 나르는 부분을 페이로드(Payload)라 한다.
-> http header는 아래와 같은 형식을 따른다.
    - <field_name> : <field_value>
    - field_name은 대소문자 구분이 없다.
    - 예시. Content-Type : text/html;charset=UFT-8
    - 예시. Content-Length : 3423
    - 예시. Host : www.google.com
-> HTTP 헤더는 HTTP 전송에 필요한 모든 부가정보를 담기 위해 사용한다.

tip!!!!!
⬇️⬇️⬇️⬇️⬇️⬇️

Content-Type: 표현 데이터의 형식
    - 예시. application/json
Content-Encoding: 표현 데이터의 압축 방식
    - 예시. gzip
Content-Language: 표현 데이터의 자연 언어
    - 예시. ko / en
Content-Length: 표현 데이터의 길이
    - 예시. 5
(Transfer-Encoding은 전송 시 어떤 인코딩 방법을 사용할 것인가를 명시한다. Transfer-Encoding 사용 시 Content-Length를 사용하면 안된다. 현재는 Transfer-Encoding 보다는 Content-Encoding을 사용하며, Transfer-Encoding을 사용하는 경우 chunked의 방식으로 사용한다. chunked 방식의 인코딩은 많은 양의 데이터를 분할하여 보내기 때문에 전체 데이터의 크기를 알 수 없다, 때문에 표현 데이터의 길이를 명시해야하는 Content-Length 헤더와 함께 사용할 수 없게되는것이다.)



-------------------------------------------------------------



HTTP 주요 헤더?

요청(Request)에서 사용되는 헤더?

-> From: 유저 에이전트의 이메일 정보
    - 일반적으로 잘 사용하지 않음
    - 검색 엔진에서 주로 사용
    - 요청에서 사용

-> Referer: 이전 웹 페이지 주소
    - 현재 요청된 페이지의 이전 웹 페이지 주소
    - A → B로 이동하는 경우 B를 요청할 때 Referer: A 를 포함해서 요청
    - Referer 를 사용하면 유입경로 수집 가능
    - 요청에서 사용
    - referer는 단어 referrer의 오탈자이지만 스펙으로 굳어짐

-> User-Agent: 유저 에이전트 애플리케이션 정보
    - 클라이언트의 애플리케이션 정보(웹 브라우저 정보, 등등)
    - 통계 정보
    - 어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능
    - 요청에서 사용
    - e.g.
        ㄴ user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/
        537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36

-> Host: 요청한 호스트 정보(도메인)
    - 요청에서 사용
    - 필수 헤더
    - 하나의 서버가 여러 도메인을 처리해야 할 때 호스트 정보를 명시하기 위해 사용
    - 하나의 IP 주소에 여러 도메인이 적용되어 있을 때 호스트 정보를 명시하기 위해 사용

-> Origin: 서버로 POST 요청을 보낼 때, 요청을 시작한 주소를 나타냄
    - 여기서 요청을 보낸 주소와 받는 주소가 다르면 CORS 에러가 발생한다.
    - 응답 헤더의 Access-Control-Allow-Origin와 관련

-> Authorization: 인증 토큰(e.g. JWT)을 서버로 보낼 때 사용하는 헤더
    - “토큰의 종류(e.g. Basic) + 실제 토큰 문자”를 전송
    - e.g.
        ㄴ Authorization: Basic {실제 토큰 문자}




응답(Response)에서 사용되는 헤더?

-> Server: 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보
    - 응답에서 사용
    - e.g.
        ㄴ Server: Apache/2.2.22 (Debian)
        ㄴ Server: nginx

-> Date: 메시지가 발생한 날짜와 시간
    - 응답에서 사용
    - e.g.
        ㄴ Date: Tue, 15 Nov 1994 08:12:31 GMT

-> Location: 페이지 리디렉션
    - 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 리다이렉트(자동 이동)
    - 201(Created): Location 값은 요청에 의해 생성된 리소스 URI
    - 3xx(Redirection): Location 값은 요청을 자동으로 리디렉션하기 위한 대상 리소스를 가리킴

-> Allow: 허용 가능한 HTTP 메서드
    - 405(Method Not Allowed)에서 응답에 포함
    - e.g.
        ㄴ Allow: GET, HEAD, PUT

-> Retry-After: 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
    - 503(Service Unavailable): 서비스가 언제까지 불능인지 알려줄 수 있음
    - e.g.
        ㄴ Retry-After: Fri, 31 Dec 2020 23:59:59 GMT(날짜 표기)
        ㄴ Retry-After: 120(초 단위 표기)



-------------------------------------------------------------



컨텐츠 협상 헤더?

-> 협상 헤더는 요청시에만 사용한다.

tip!!!!!
⬇️⬇️⬇️⬇️⬇️⬇️

Accept: 클라가 선호하는 미디어 타입 전달
Accept-Charset: 클라가 선호하는 문자 인코딩
Accept-Encoding: 클라가 선호하는 압축 인코딩
Accept-Language: 클라가 선호하는 자연 언어
    - 예시. Accept-Language : ko
(만약 클라에서 한국어를 선호해 위 예시처럼 요청을 보냈는데, 응답해주는 서버에서는 한국어를 지원하지 않고 우선순위 언어가 독일어이고, 영어도 지원하는 상황이라면 응답을 차선책인 영어로라도 받을 수 있게 요청 시 선호 언어의 우선순위를 정해줘야 한다 /  예시. Accept-Language : ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7)
(우선순위는 1부터 0까지 우선순위를 부여했다.)




-------------------------------------------------------------




웹캐시?

캐시의 기본 원리 및 적용?
-> 클라이언트가 logo.jpg 이미지에 대한 요청을 보내고 서버가 해당 이미지에 대한 응답을 줄 때, HTTP 헤더가 0.1M, 바디가 1.0M로 총 1.1M로 가정해보자.
-> 캐시가 없다면 같은 이미지를 다시 요청하더라도 첫 번째처럼 똑같이 1.1M의 응답을 보내게 된다.
-> 이 경우 logo.jpg 데이터가 변경되지 않아도 계속 데이터를 새로 다운받아야 하기 때문에 만약 이러한 용량이 커지면 커질수록 비용이 커지고 브라우저의 로딩속도가 느려질 수 있다.
-> 캐시(데이터나 값을 미리 복사해 놓는 임시 장소)를 사용해서 이러한 단점들을 보완할 수 있다.
-> 캐시(cache)는 컴퓨터 과학에서 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킨다.
-> 첫 요청시 응답으로 받은 데이터를 캐시에 미리 복사해 놓으면 그 다음부터는 같은 데이터 요청 시 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있다.
-> 다만 브라우저에 캐시를 저장할 땐 헤더에 cache-control 속성을 통해 캐시가 유효한 시간을 지정해 제한을 두는게 좋다.


캐시 검증 헤더와 조건부 요청?

-> 앞선 설명에 의하면 캐시가 만약 유효시간이 초과하게 되면 다시 요청을 보내 새로운 데이터로 캐시를 업데이트 하게 되었다. 근데 만약 캐시 유효시간이 지난 상황에서, 캐시에 있는 데이터에는 변경 사항이 없을때, 이미 받아놓은 캐시 데이터를 그대로 써도 되는 상황이라면 어떻게 이를 검증하고 그대로 사용 할 수 있을지 알아보자.

-> 검증 헤더 Last Modified를 이용해 캐시의 수정시간을 알 수 있다. Last Modified는 데이터가 마지막으로 수정된 시간정보를 헤더에 포함한다. 이로 인해 응답 결과를 캐시에 저장할 때 데이터 최종 수정일도 저장된다.

-> 요청 시 if-Modified-Since 헤더를 이용해 클라가 서버에게, 야 내가 가지고 있는 캐시의 데이터에는 데이터의 마지막 수정일이 언제언제 라던데 그 뒤로 수정된적 있냐? 라고 물어본다.

-> 그러면 서버는 캐시의 데이터 마지막 수정일과 서버에서 보관중이던 데이터의 마지막 수정일을 비교해보고, 변한게 없다면 응답시 상태코드 304 Not Modified로 변경된거 없다 야~라고 답을 해준다.

-> 이렇게 서버에서 변경한게 없다며 상태코드로 응답을 보낼땐 응답 시 응답 body가 없을거기때문에 헤더만 포함된 0.1M만 응답으로 전송해준다.

-> 그러면 클라는 해당 응답을 받은 뒤 캐시를 갱신해주고 다시 일정시간동안 캐시가 유효하게 되는것이다.

-> 결론적으로 위 설명한것처럼 Last-Modified와 If-Modified-Since를 사용해서 요청, 응답을 받게되면 결국엔 클라가 서버에서 뭔가 데이터를 받게 되겠지만 처음처럼 1.1M를 받는것이 아닌 응답에 body가 없을거기 때문에 처음과 비교했을때 비교적 적은 데이터만 받을 수 있게 되어 매우 실용적으로 요청/응답을 할 수 있게된다.

-> 그치만 세상에 완벽한건 없다고, Last-Modified와 If-Modified-Since는 아래와 같은 단점을 가지고 있다.
    - 1초 미만 단위로 캐시 조정이 불가
    - 날짜 기반의 로직 사용
    - 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우
    - 서버에서 별도의 캐시 로직을 관리하고 싶은 경우,
        - 예시. 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우


-> 앞서 설명한 Last-Modified와 If-Modified-Since보다 좀 더 간단한 방식으로 ETag와 If-None-Match 검증헤더가 있다.

-> 서버에서 완전히 캐시를 컨트롤하고 싶은 경우 ETag를 사용할 수 있다.

-> ETag와 If-None-Match의 작동방식은,
    - 서버에서 헤더에 ETag를 작성해 응답한다.
    - 클라이언트의 캐시에서 해당 ETag 값을 저장한다.
    - 만약 캐시시간이 초과되서 다시 요청을 해야하는 경우라면 이때 ETag값을 검증하는 If-None-Match를 요청 헤더에 작성해서 보낸다.
    - 서버에서 데이터가 변경되지 않았을 경우 ETag는 동일하기에 그래서 If-None-Match는 거짓이 된다.
    - 이 경우 서버에서는 304 Not Modified를 응답하며 이때 역시 HTTP Body는 없다.
    - 브라우저 캐시에서는 응답 결과를 재사용하고 헤더 데이터를 갱신한다.

-> ETag와 If-None-Match를 정리해보자면,
    - 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받는 방식
    - 캐시 제어 로직을 서버에서 완전히 관리
    - 클라는 단순히 이 값을 서버에서 제공(클라는 캐시 매커니즘을 모름)
        - 예시. 서버는 베타 오픈 기간인 3일 동안 파일이 변경되어도 ETag를 동일하게 유지
        - 예시. 어플리케이션 배포 주기에 맞춰 ETag 갱신


tip!!!!!
⬇️⬇️⬇️⬇️⬇️⬇️

Cache-Control: max-age
    - 캐시 유효 시간, 초 단위
Cache-Control: no-cache
    - 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증을 하고 사용
Cache-Control: no-store
    - 데이터에 민감한 정보가 있으므로 저장하면 안됨
    (메모리에서 사용하고 최대한 빨리 삭제)


tip!!!!!
⬇️⬇️⬇️⬇️⬇️⬇️

Expires: Wed, 15 Sep 2021 03:36:02 GMT

    - 캐시 만료일을 정확한 날짜로 지정
    - http 1.0부터 사용
    - 지금은 더 유연한 Cache-Control: max-age 사용 권장
    - Cache-Control: max-age와 함께 사용하면 Expires는 무시됨





-------------------------------------------------------------





프록시 캐시(Proxy Cache)?

-> 프록시란, 클라이언트와 서버 사이에 대리로 통신을 수행하는 것을 가리켜 ‘프록시(Proxy)’, 그 중계 기능을 하는 서버를 프록시 서버라고 한다.
-> 클라이언트, 혹은 반대로는 서버가 다른 네트워크에 간접적으로 접속 할 수 있기 때문에, 보안, 캐싱을 통한 성능, 트래픽 분산 등의 장점을 가진다.

-> 한국에 있는 클라이언트에서 특정 데이터가 필요한 상황인데 해당 데이터의 원 서버가 미국에 있다고 가정해보자.
-> 한국에서 미국까지 직접 접근하여 이미지를 가져오는데 0.5초 가량 걸린다고 하면 한국에 있는 클라이언트는 모두 0.5초 가량을 기다려야 해당 이미지를 받을 수 있게된다.
(위에서 언급한 예시는 매우 긍정적인 상황이고, 실제로는 더 많은 시간이 걸릴 수 있다.)
-> 하지만 우리는 유튜브와 같은 해외 사이트에서 위와 같은 불편한 없이 빠르게 영상을 시청할 수 있다, 왜그럴까?
-> 클라이언트와 원 서버 사이에 위치한 프록시 캐시 서버를 도입했기 때문이다.
-> 한국에 프록시 캐시서버를 두고 한국의 클라이언트는 프록시 캐시서버를 통해 자료를 가져오도록 해보자. 여러 사람이 찾는 자료일수록 이미 캐시에 등록되어있기 때문에 훨씬 빠른 속도로 자료를 가져올 수 있게된다. 즉 프록시 서버가 클라이언트가 있는 같은 한국에 있기 때문에 해외에서 직접 가져오는것보다 훨씬 더 빠르게 받아올 수 있게 되는 것이다.
-> 이때 클라이언트에서 사용하고 저장하는 캐시를 private 캐시라 하고, 프록시 캐시 서버의 캐시를 public 캐시라고 한다.


tip!!!!!
⬇️⬇️⬇️⬇️⬇️⬇️

프록시 캐시와 관련된 헤더?

Cache-Control: public
    - 응답이 public 캐시에 저장되어도 됨
Cache-Control: private
    - 응답이 해당 사용자만을 위한 것, private 캐시에 저장해야 함(기본값)
Cache-Control: s-maxage
    - 프록시 캐시에만 적용되는 max-age
Age: 60 (HTTP 헤더)
    - 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)



-> 클라이언트가 캐시를 적용하지 않아도 임의로 브라우저가 캐시를 적용하는 경우, 특정 페이지에서 캐시가 되면 안되는 정보(e.g.통장 잔고)가 있다면 어떻게 이를 무효화할 수 있는지 알아보자.

tip!!!!!
⬇️⬇️⬇️⬇️⬇️⬇️

캐시를 무효화할 수 있는 헤더?

Cache-Control: no-cache
    - 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용(이름에 주의)
Cache-Control: no-store
    - 데이터에 민감한 정보가 있기에 저장하면 안됨
    (메모리에서 사용하고 최대한 빨리 삭제)
Cache-Control: must-revalidate
    - 캐시 만료 후 최초 조회 시 원 서버에 검증해야함
    - 원 서버 접근 실패 시 반드시 오류가 발생해야함
        ㄴ 504(Gateway Timeout)
    - must-revalidate은 캐시 유효 시간이라면 캐시를 사용함
Pragma: no-cache
    - HTTP 1.0 하위 호환

-> 캐시를 무효화를 확실하게 해야하는 경우라면? Pragma와 같은 하위호환까지 포함하여 아래와같이 적용해야한다.
    - Cache-Control: no-cache, no-store, must-revalidate
    - Pragma: no-cache




-> no-cache와 must-revalidate 모두 원 서버에 검증해야하지만 그에 대한 응답에 대해 다른 점이 있다. 어떤점이 다른지 no-cache의 경우부터 알아보자.
    - 캐시 서버 요청을 하면 프록시 캐시 서버에 도착하면 no-cache인 경우 원 서버에 요청을 하게 된다.
    그리고 원 서버에서 검증 후 304 응답을 하게 된다.
    - 만약 프록시 캐시 서버와 원 서버간 네트워크 연결이 단절되어 접근이 불가능 하다면, no-cache에서는 응답으로 오류가 아닌 오래된 데이터라도 보여주자라는 개념으로 200OK으로 응답을 하게 된다.
    - 하지만 must-revalidate 라면 원 서버에 접근이 불가할 때 504 Gateway Timeout 오류를 보내게 된다.
    - 통장 잔고 등 중요한 정보가 원 서버를 못 받았다고 해서 예전 데이터로 뜬다면 큰 문제가 생기기때문에 이런 경우 must-revalidate를 써야 한다.



-------------------------------------------------------------



CDN(Content Delivery Network)? / DNS(Domain Name System)?

->
