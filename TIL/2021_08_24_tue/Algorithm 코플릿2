알고리즘 코플릿 2번

문제
-> 편의점에서 아르바이트를 하고 있는 중에, 하필이면 피크 시간대에 손님에게 거스름돈으로 줄 동전이 부족하다는 것을 알게 되었습니다.
현재 가지고 있는 동전은 1원, 5원, 10원, 50원, 100원, 500원으로 오름차순으로 정렬되어 있고, 각 동전들은 서로 배수 관계에 있습니다.
동전 개수를 최소화하여 거스름돈 K를 만들어야 합니다. 이때, 필요한 동전 개수의 최솟값을 구하는 함수를 작성해 주세요.

인자1:k
-> number 타입의 k
-> 1 <= k <= 100,000,000

출력
-> number 타입의 거스름돈 K원을 만드는데 필요한 동전 개수의 최솟값을 반환해야 합니다.

입출력 예시
⬇️⬇️⬇️⬇️⬇️⬇️

const output1 = test1(4000);
console.log(output1); // --> 8

// 4000원을 받았을 때 500원짜리 동전 8개를 반환합니다.

const output2 = test1(4972);
console.log(output2); // --> 18

// 4972원을 받았을 때 500원짜리 동전 9개, 100원짜리 동전 4개, 50원짜리 동전 1개, 10원짜리 동전 2개, 1원짜리 동전 2개, 총 18개를 반환합니다.

문제 풀이
⬇️⬇️⬇️⬇️⬇️

function partTimeJob(k) {
  // TODO: 여기에 코드를 작성하세요.
  let coins = [500, 100, 50, 10, 5, 1]; // coins라는 배열에다가 동전들을 넣어주고,
  let cnt = 0; // 카운트를 0으로 지정,

  for(let i = 0; i < coins.length; i++) { // for 반복문으로 coins의 배열을 쭉 반복,
    if(k > 0) { // k가 0보다 클때까지만을 조건으로 주고,
      let sum = parseInt(k / coins[i]); // sum을 새로 선언, k를 coins의 동전으로 나눈 값으로 나눠주고, 그것을 parseInt해서 sum에 할당,
      cnt = cnt + sum; // 카운트에다가 sum을 더해주고,
      k = k - (coins[i] * sum); // k를 사용한 동전만큼의 값을 빼서 새로 할당,
    }
  }
  return cnt; // 카운트를 리턴한다.
}
