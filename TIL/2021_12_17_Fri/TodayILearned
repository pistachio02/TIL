++++++++++++++++++++++

    시간복잡도?

    - Big-O(빅-오)
        - 최악의 경우를 고려함. 즉 최악의 경우 시간이 어느정도까지 걸릴 수 있다를 나타냄.
        - 가장 많이 사용함.
    - Big-Ω(빅-오메가)
        - 최선의 경우를 고려함. 즉 최선의 경우 시간이 어느정도까지 걸릴 수 있다를 나타냄.
    - Big-θ(빅-세타)
        - 중간(평균)의 경우를 고려함. 즉 몇번 실행했을때 시간이 평균 어느정도까지 걸릴 수 있다를 나타냄.

    - O(1)
        - Constant Complexity 라고 하며, 입력값이 증가하더라도 시간이 늘어나지 않는다. 즉 입력값의 크기와 관계없이 즉시 출력값을 얻어낼 수 있다는 의미이다.
        - 예시는 아래와 같다.
            function O1_algorithm(arr, index) {
                return arr[index];
            }

            let arr = [1, 2, 3, 4, 5];
            let index = 1;
            let result = O_1_algorithm(arr, index);
            console.log(result); // 2
        
        위 예시를 보면 함수의 인자로 전달되는 입력값이 아무리 커져도 즉시 출력값을 얻어낼 수 있다는걸 알 수 있다. 즉 예를 들어 arr의 길이가 100만이라 하더라도 즉시 해당 index에 접근해 값을 반환할 수 있다는 말이다.

    - O(n)
        - Linear Complexity 라고 하며, 입력값이 증가함에 따라 시간 또한 같은 비율로 증가하는 것을 의미한다. 즉 입력값이 1일때 1초의 시간이 걸리고, 입력값을 100으로 증가시켰을땐 100초의 시간이 걸린다는 의미이다. 위와 같은 알고리즘을 구현했다면 해당 알고리즘은 O(n)의 시간 복잡도를 가진다고 할 수 있다.
        - 예시는 아래와 같다.
            function On_algorithm(n) {
                for(let i = 0; i < n; i++) {
                // do something for 1 second
                }
            }
        
        위 예시를 보면 함수의 입력값 n이 1 증가할 때마다 코드의 실행 시간이 1초씩 증가하게 된다. 즉 입력값이 증가함에 따라 걸리는 같은 비율로 걸리는 시간이 늘어나게 될때에 이러한 함수는 O(n)의 시간 복잡도를 가진다고 볼 수 있다.
        만약 위 함수에서 do something for 1 second이 아니고 
        만약 위 함수에서 do something for 1 second이 아니고 do something for 2 second 이나 do something for 5 second 이라 하더라도 시간이 늘어났기때문에 시간복잡도가 O(2n) 이나 O(5n) 아니야? 라고 생각할 수 도 있겠지만, 그렇지 않다. 중요한것은 증가하는 입력값과 같은 비율로 시간이 증가할때를 고려하는것이기 때문에 do something for 2 second 이나 do something for 5 second 이라 하더라도 입력값과 같은 비율로 시간이 증가하게 된다면 해당 함수는 O(n)의 시간 복잡도를 가졌다고 볼 수 있다.
    
    - O(log n)
        - Logarithmic Complexity 라고 하며, Big-O표기법중 O(1) 다음으로 빠른 시간 복잡도를 가진다. 해당 시간 복잡도를 가장 이해하기 쉽게 설명하자면 Up & Down 게임을 예시로 들면 이해하기가 조금 편하다. 1부터 50까지 숫자 중 랜덤으로 아무 숫자나 하나를 정해서 상대방이 해당 숫자를 맞추는 게임인데, 상대방이 말하는 숫자를 듣고 랜덤으로 정한 하나의 숫자가 어디에 있는지 Up인지 Down인지 알려주고 그런식으로 쭉 계속 해나가면서 처음 랜덤으로 정한 숫자를 맞추는 게임이다. 이 게임의 특징은 한번 숫자를 말할때마다 숫자가 Up인지 Down인지 맞출 수 있는 경우의 수가 줄어든다는것인데 O(log n)의 시간 복잡도를 가진 알고리즘도 이와 같다.
    
    - O(n2)
        - Quadratic Complexity 라고 하며, 입력값이 증가함에 따라 시간이 입력값의 제곱수 비율로 증가하는 것을 의미한다. 즉 입력값이 1일때 1초의 시간이 걸리던 알고리즘에 입력값을 5로 줬더니 25(5x5)초의 시간이 걸렸다 라고 한다면 해당 알고리즘은 O(n2)의 시간 복잡도를 가진 알고리즘이라고 할 수 있겠다.
        - 예시는 아래와 같다.
            function O_quadratic_algorithm(n) {
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                    // do something for 1 second
                    }
                }
            }

            function another_O_quadratic_algorithm(n) {
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        for (let k = 0; k < n; k++) {
                        // do something for 1 second
                        }
                    }
                }
            }
    
    - O(2n)
        - Exponential Complexity 라고 하며, Big-O 표기법 중 가장 느린 시간 복잡도를 가진다. 종이를 42번 접으면 그 두께가 지구에서 달까지의 거리보다 커진다는 이야기가 있는데 그 이유는 고작 종이처럼 얇은 것일지라도 한번 접을때마다 그 두께가 2배로 늘어나기 때문이다. 즉 입력값이 +1로 증가할때마다 따라 걸리는 시간이 두배로 늘어나는 알고리즘이 있을때 이러한 알고리즘을 O(2n)의 시간 복잡도를 가진 알고리즘이라고 한다.
        - 예시는 아래와 같다.
            function fibonacci(n) {
                if (n <= 1) {
                    return 1;
                }
                return fibonacci(n - 1) + fibonacci(n - 2);
            }
        
        재귀로 구현한 피보나치 수열은 O(2n)의 시간 복잡도를 가진 대표적인 알고리즘으로, 만약 n값을 100 이상으로 한다면 평생ㅇ 결과를 반환받지 못할 수 도 있다.

++++++++++++++++++++++

    Greedy Algorithm

    - 선택의 순간마다 당장 눈앞에 보이는 최적의 상황만을 쫓아 최종적인 해답에 도달하는 방법이다.
    - 편의점 알바를 할때 손님이 4040원 어치의 물건을 사려고 하고 5000원을 주면서 거스름돈(동전)은 최소한으로 해서 거슬러 달라고 했다 치자. 그럴때 최소한의 동전으로 거슬러 주려면 우선 거스름돈 960원의 값에서 가장 큰 값의 동전인 500원을 하나 선택하고 생각을 해보는거다. 500원짜리 동전 하나를 더 선택할 순 없나? 만약 500원짜리 동전을 하나 더 선택하게 되면 거스름돈인 960원보다 금액이 커지기 때문에 적합하지 않다 라고 판단을 내리고 그 다음으로 넘어가 500원보다 그 다음으로 큰 동전인 100원짜리 동전을 4개 선택을 한다. 그리고 또 생각을 하는거다. 100원짜리 동전 하나를 더 선택할 순 없는지, 만약 100원짜리 동전을 하나 더 선택하게 된다면 금액이 또 거스름돈보다 커지기 때문에 적합하지 않다고 판단 내리고 다음으로 큰 동전으로 또 넘어가고 넘어가고 계속 그런식으로 해서 적절하게 금액에 맞게 최소한의 동전수로 거스름돈을 거슬러 주는것이다.
    - 위와같은 방식으로 문제를 해결하게 된다면 비교적 빠른 시간내에 어느정도 합리적인 결과를 도출해낼 수 있지만 항상 가장 최적의 결과를 도출하진 못하게 된다.
    - 한가지 예를 더 들자면 내가 도둑이고 딱 35kg만 들어갈 수 있는 가방이 있다고 했을때, 내가 훔칠 수 있는 물건들이 아래와 같다고 해보자.
        - 그림작품 30kg, 3000 달러의 값어치.
        - 티비 25kg, 2500 달러의 값어치.
        - 컴퓨터 20kg, 2000 달러의 값어치.
        - 다이아 반지 15kg, 1500 달러의 값어치.
    - 위와 같은 물건들이 있을때 Greedy Algorithm을 적용해서 물건을 훔치게 된다면 우선 가장 비싼 물건을 선택해 가방에 담아야 하는데, 가장 비싼 물건인 그림작품을 가방에 넣게 되면 35kg 중 30kg가 차기 때문에 다음 물건을 넣을 수 없게 되고 그렇게 되면 내가 훔치는 물건의 값은 3000 달러에 그치게 된다.
    - 위와같은 방법이 최적의 방법이라고 할 수 없는게, 만약 컴퓨터 20kg와, 다이아반지 15kg을 훔치게 되면 총 35kg의 가방도 꽉 채울 수 있고 물건들의 값어치도 3500 달러가 되기때문에 가장 최적의 방법으로 물건을 훔지는게 가능하다. 
    - 이러한 경우도 있을 수 있기 때문에 Greedy Algorithm이 항상 최적의 결과를 도출해낼 수 없다고 하는것이다.

++++++++++++++++++++++

    완전탐색

    - 단순무식한 방법이지만 답이 무조건 있다 라는 강력함이 있다.
    - 예를들면 1부터 100까지의 숫자 중 원하는 수를 찾기 위해 하나씩 다 탐색해보면서 답을 찾아가는걸 완전 탐색이라고 한다. 무조건 답을 찾을 수는 있지만 효율적으로 찾지는 못하는 방법이고, 최악의 경우 100번의 탐색을 거쳐야 하기 때문에 이러한 경우 완전탐색이라고 할 수 있다.

++++++++++++++++++++++
