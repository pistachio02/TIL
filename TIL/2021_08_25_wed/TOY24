<TIL>

Toy24번

문제
-> 정수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴해야 합니다.

인자 : arr
-> number 타입을 요소로 갖는 배열
-> arr[i]는 0 이상의 정수
-> arr.length 100,000 이하

출력
-> number 타입을 요소로 갖는 배열을 리턴해야 합니다.
-> 배열의 요소는 오름차순으로 정렬되어야 합니다.
-> arr[i] <= arr[j] (i < j)

주의사항
-> 기수 정렬을 구현해야 합니다.
-> arr.sort 사용은 금지됩니다.
-> 입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.

입출력 예시
⬇️⬇️⬇️⬇️⬇️⬇️

let output = radixSort([3, 1, 21]);
console.log(output); // --> [1, 3, 21]

// 인자 arr로 전달된 정수를 소요로 가지는 배열을 받아, 오름차순으로 정력해야하나, arr.sort를 사용하지 않고 기수정렬을 사용해야함.

힌트!!!!!!!!!
⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️
-> 기수 정렬(radix sort)은 내부적으로 계수 정렬(counting sort)을 사용합니다.
-> 계수 정렬을 먼저 학습하고, 어떤 경우에 기수 정렬을 사용하는지 학습하도록 합니다.

문제 풀이
⬇️⬇️⬇️⬇️⬇️

function radixSort(arr) {
  // todo: 여기에 코드를 작성합니다.
  function getMax(arr) {
    return arr.reduce((max, item) => {
      if(item > max) return item;
      return max;
    }, 0);
  }

  function countingSort(arr, radix) {
    const N = arr.length;
    const output = Array(N).fill(0);
    const count = Array(10).fill(0);

    arr.forEach((item) => {
      const idx = Math.floor(item / radix) % 10;
      count[idx]++;
    });

    count.reduce((totalNum, num, idx) => {
      count[idx] = totalNum + num;
      return totalNum + num;
    });

    let i = N - 1;
    while (i >= 0) {
      const idx = Math.floor(arr[i] / radix) % 10;
      output[count[idx] - 1] = arr[i];
      count[idx] -= 1;
      i--;
    }

    return output;
  }

  let left = [];
  let right = [];
  arr.forEach((item) => {
    if (item >= 0) right.push(item);
    else left.push(item * -1);
  });

  let max = getMax(left);
  let radix = 1;
  while (parseInt(max / radix) > 0) {
    left = countingSort(left, radix);
    radix *= 10;
  }

  max = getMax(right);
  radix = 1;
  while (parseInt(max / radix) > 0) {
    right = countingSort(right, radix);
    radix *= 10;
  }

  return left
    .reverse()
    .map((item) => item * -1)
    .concat(right);

}


계수정렬? (counting sort?)
⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️

정렬 알고리즘으로 O(n)의 시간 복잡도를 가진다.
정렬 과정을 살펴보자면, 우선
배열에 담긴 각 숫자들이 몇번 등장하는지 세어준다.

예) [3, 5, 2, 1, 0, 0, 1, 3, 2, 4, 5, 4, 5, 1, 3, 2, 4] 라면 각각
    0=3번, 1=3번, 2=3번, 3=3번, 4=3번, 5=3번 등장한다 라는 식으로 몇번 등장하는지 세어줌.

아마 이래서 이름도 counting sort일지도?

이렇게 숫자를 세어준 상황에서 작은 순서대로 몇번 등장하는지 만큼 순서대로 찍어주면 간단하게 sort할 수 있을것 같지만,
만약 배열 안에 등장하는 숫자중 갑자기 뜬금없이 큰 숫자가 나오게 된다면 그 숫자와 비교적 작은 숫자들 사이에 있는 숫자들까지도 순회해야하기 때문에(무의미한순회) 그렇게 sort를 해버리면 숫자 크기에 시간복잡도가 큰 영향을 받기에 효율적이지 않다. 해서 위처럼 각 숫자가 몇번 등장하는지 세어준 다음에 그것들을 (등장횟수를) 누적합으로 바꿔준다.

예) 0=3번등장이니 3, 1=3번등장이니 (3+3=6) 6, 2=3번등장이니 (6+3=9) 9, 3=3번등장이니 (9+3=12) 12, 4=3번등장이니 (12+3=15) 15, 5=3번등장이니 (15+3=18) 18

위 배열을 예시로 들자면 정렬되지 않은 위 배열의 가장 뒤에서부터 앞으로 순회하면서 각 숫자의 누적합을 인덱스로 하여 새로운 배열에 넣어주면 된다.

예) 위 배열의 가장 뒤에 있는 숫자는 4이고, 4의 누적합은 15이니까, 새로운 배열의 15번째 자리에 4를 우선 1개 할당해주고, 할당한 뒤 4가 3번 등장했는데 할당은 아직 1번만 해줬으니 나머지 등장한 2개도 할당을 해줘야 하는데 그러기 위해선 우선 지금 새로운 배열의 15번째 자리에 4가 1개 할당되었으니 다음 할당을 위해 4의 누적합을 15에서 한개 줄인 14로 바꿔준다. 그래야 다음에 4를 할당할 시 14번째 자리에 들어가게 될테니.

이런식으로 위 정렬되지 않은 배열을 맨 뒤 자리부터 맨 앞자리까지 우선 한번 할당해준다. 그러면 각각의 숫자들이 총 3번씩 방문했는데 1번씩 새로운 배열에 할당되었으므로(또 각각 할당하면서 누적합을 1개씩 줄여서 바꿔줬으므로) 위 과정을 2번(총3번) 더 반복한다. 그렇게 하면 결국 오름차순으로 정렬된 새로운 배열이 만들어질테고 그렇게 sort를 하는것이 counting sort(계수정렬)이다.

단점). 해당 정렬은 시간 복잡도 면에서 보자면 quick sort보다 훨씬 유리해 보일 수 있으나 아까 말했듯 중간에 갑자기 큰 숫자가 하나 끼게 된다면 무의미한 순회를 해야할 수 도 있기에 엄청난 메모리 낭비를 야기할 수 있다. 따라서 해당 정렬은 정렬하는 숫자가 특정한 범위(예. 0~5까지) 안에 있을때 사용하면 좋다.




기수정렬? (radix sort?)
⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️⬇️

기수정렬은 낮은 자리수부터 비교하여 정렬해 간다는 것을 기본 개념으로 하는 정렬 알고리즘이다.
비교연산을 하지 않아서 정렬속도가 빠르지만 데이터 전체 크기에 기수 테이블의 크기만한 메모리가 더 필요하다.

방식?
우선 0~9까지의 bucket(queue자료구조의)을 준비하고,
모든 데이터에 대하여 가장 낮은 자리수에 해당하는 bucker에 차례대로 데이터를 넣는다.
0부터 차례대로 버킷에서 아까 넣은 데이터를 다시 가져온다.
가장 높은 자리수를 기준으로 하여 자리수를 높여가며 2번 3번 과정을 반복한다.

(이렇게만 읽으면 이해가 어려울 수 있는데)

예를 들어 배열이 [15, 27, 64, 25, 50, 17, 39, 28] 이렇게 있다면, 가장 낮은 자리수는 1의 자리수이기때문에
거기서부터 해당하는 자리에 (버킷)에 넣는다. 우선 15는 1의 자리가 5이니까 버킷의 5번째에 넣고, 27은 1의 자리가 7이니까 버킷의 7번째에 넣고, 그런식으로 배열에 있는 모든 요소를 버킷에 넣은다음, 버킷에 담은 숫자들을 다시 차례대로 배열로 가져온다.
그렇게 하면 [50, 64, 15, 25, 27, 17, 28, 39] 이렇게 가져오게 될테고, 이렇게 되면 이제 1의 자리에 대한 정렬은 완료된거나 그 다음으로 큰 자리수 10의 자리수대로 위 과정을 다시 반복한다. 50은 10의 자리가 5니까 버킷의 5번째에 넣고, 64는 10의 자리가 6이니까 버킷의 6의 자리에 넣고 이런식으로 쭉쭉쭉 배열을 다시 버킷에 담았다가 다시 순서대로 가져온다. 그렇게 되면 결국엔 [15, 17, 25, 27, 28, 39, 50, 64]라는 오름차순으로 정렬된 배열이 완성된다.

장점). 자리수가 고정되어있어서 안정성이 있는 정렬방식이다.
